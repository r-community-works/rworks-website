---
title: "Tidyverse with Copilot for healthcare analytics -- part 1"
subtitle: "Unless Copilot specified explicitly, all code is originally authored"
author: "Vidisha Vachharajani"
date: "2025-05-13"
descriotion: "In this post, first in a series of two focused on healthcare applications, I will introduce a complex healthcare data set and outline the problems I propose to solve using tidyverse and Copilot to facilitate nuanced argument tuning of tidyverse functions and accelerate the data analysis process."
fig-dpi: 300
fig-align: "center"
image: infographic.png
format: html
editor: source
---

## The role of healthcare analytics

The primary objective of healthcare analytics is to seek benefits for health administrators, organizations, and patients, most importantly by enhancing patient experiences and improving health outcomes. The healthcare industry generates vast amounts of data, primarily from **electronic medical records (EMH)** and **administrative** data.

![](infographic.png)

EMH data aims to improve the accuracy of diagnoses and treatment plans while enhancing overall care quality by making patients' health histories readily accessible to authorized providers. In contrast, administrative data encompasses patient interaction details, such as diagnoses and hospital readmissions, which can be analyzed to evaluate healthcare delivery, advantages, disadvantages, and cost-effectiveness.

## Using R with Copilot in healthcare

In this post, first in a series of two focused on healthcare applications, I will introduce a complex healthcare data set and outline the problems I propose to solve using tidyverse and Copilot to facilitate nuanced argument tuning of tidyverse functions and accelerate the data analysis process.


> This series is designed to help you refine and improve your data analysis skills, understand the role of AI in healthcare analytics, while demonstrating the practical application of R and Copilot in real-world scenarios.

Before we proceed, a few words of caution regarding Copilot: we will use it on a task-by-task basis rather than for the entire workflow of data exploration and hypothesis investigation. This approach allows us to leverage Copilot for challenging data wrangling and cleaning tasks, saving time and enabling deeper analytical thinking. However, it is crucial to verify the code output from any AI pair programmer—always run the code to ensure it produces the desired results and manually triangulate to confirm accuracy.

## Diabetes data from UCI

### Understanding the data

I first encountered the diabetes data a few years ago, when I was exploring the types of healthcare data sets freely available for users. The UCI machine learning repository offers a rich set of options – the diabetes data captivated me due to its size and the volume of information it gathered, where each row is an inpatient hospital diabetic encounter, i.e. diabetes was entered as a diagnosis, where lab tests were performed and medications were administered. The original paper that used this data can be found [here](https://onlinelibrary.wiley.com/doi/10.1155/2014/781670).

Let's look at the data, with an example of a diabetic encounter with a patient admitted for heart failure.

```{r}
#| label: Chunk1
#| warning: false
#| code-fold: true
#| code-summary: "Show the code for reading in data"

# --------------------------------------------- #
# Load necessary libraries
# --------------------------------------------- #
library(dplyr)
library(ggplot2)
library(tidyr)
library(kableExtra)

# --------------------------------------------- #
# Read in the data, show example row
# --------------------------------------------- #
D <- read.csv("diabetes_data.csv", sep=",")

row_ex <- t(D[47,c(-1,-2,-3,-4)])
row_ex <- data.frame("Fields" = rownames(row_ex), "Values"=row_ex[,1], row.names = NULL)

knitr::kable(
  row_ex,
  caption = 'An example data row {#tbl-ex}',
  booktabs = TRUE
) %>%
  kable_styling(full_width = F) %>%
  row_spec(c(44:46), background = "lightgray")
```

Look at the richness of the encounter data. This row is a $70+$ year old who was admitted as an elective patient, transferred from another hospital, spent $9$ days in the hospital, had $25$ lab procedures and was given $16$ medications; there was a primary diagnosis of a circulatory disease (specifically, heart failure), and an additional secondary diabetes diagnosis; the patient was given diabetes medications (one of which was insulin), which were adjusted/changed, no *A1c test* was administered*;* they were discharged to another inpatient care institution, and were readmitted in $<30$ days. **The 3 primary response variables that we will examine later are colored in GRAY.**

### Data transformation with some help from Copilot

There are $100,000+$ rows of such encounters! To be able to use this data, we need to get to the bottom of its $50+$ fields and identify which ones will tell us the story that will have implications for patient management and improved health outcomes. Let's consider some examples.

Hospital admission and diagnoses fields like `admission_type_id`, `discharge_disposition_id`, `admission_source_id` and `diag_1` are defined using codes that are mapped to values in a separate data file provided with the data, which we will use to transform these fields into a usable format. We will explore how Copilot can assist with this transformation.

When using Copilot directly in RStudio, it is essential to provide sufficient detail in your prompts. We will begin with `admission_type_id`:

![](admission_type.png)

> ***Notes on Copilot:** Its good to see we didn't even have to specify the use of `dplyr` for the transformation! Note that without Copilot, my original strategy was to use `if-else`, which makes for a slightly more unwieldy code chunk; I much prefer the use of `case-when`.*

Now let's handle the slightly more complicated `diag_1`, which defines primary diagnosis using ICD9 codes; see Table $2$ [here](https://onlinelibrary.wiley.com/doi/10.1155/2014/781670). We will need to specify the mapping very clearly, as below.

![](diag_1.png)

These transformations will help us conduct a range of exploratory analyses and visualizations. For instance, primary diagnoses can significantly influence whether a patient receives the *A1c test* for diabetes. Let's prepare the data to implement these in part $2$.

```{r}
#| label: Chunk2
#| warning: false
#| code-fold: true
#| code-summary: "Show the code for transformation"

# --------------------------------------------- #
# Transformations --> admission_type_id, diag_1, A1c, readmitted
# --------------------------------------------- #

D <- D %>%
  mutate(admission_type = case_when(
    admission_type_id == 1 ~ "Emergency",
    admission_type_id == 2 ~ "Urgent",
    admission_type_id == 3 ~ "Elective",
    admission_type_id == 4 ~ "Newborn",
    admission_type_id == 5 ~ "Not Available",
    admission_type_id == 6 ~ "NULL",
    admission_type_id == 7 ~ "Trauma Center",
    admission_type_id == 8 ~ "Not Mapped"
  ), primary_diag = case_when(
    diag_1 %in% c(390:459, 785) ~ "Circulatory",
    diag_1 %in% c(460:519, 786) ~ "Respiratory",
    diag_1 %in% c(520:579, 787) ~ "Digestive",
    diag_1 %in% c(580:629, 788) ~ "Genitourinary",
    diag_1 %in% c(630:679) ~ "Pregnancy",
    diag_1 %in% c(680:709, 782) ~ "Skin",
    diag_1 %in% c(710:739) ~ "Musculoskeletal",
    diag_1 %in% c(740:759) ~ "Congenital",
    diag_1 %in% c(800:999) ~ "Injury",
    grepl("^250", diag_1) ~ "Diabetes",
    is.na(diag_1) ~ "Missing",
    TRUE ~ "Other"
  ), a1c=ifelse(A1Cresult=="None", "not measured", "measured"), 
  reAdmit=ifelse(readmitted=="<30", "early readmit", "no/late readmit"))
```

```{r}
#| label: Chunk3
#| warning: false
#| code-fold: true
#| code-summary: "Show the code for testing Copilot output"

# --------------------------------------------- #
# Testing the Copilot output for diagnoses
# --------------------------------------------- #

testDiag <- D %>% subset(primary_diag=="Respiratory") %>% group_by(diag_1, primary_diag) %>% summarise(n=n())
result <- testDiag %>% 
  group_by(primary_diag) %>%
  summarise(diag_1 = paste(diag_1, collapse = ", ")) %>%
  ungroup()


knitr::kable(
  #list(testDiag[1:21,], testDiag[22:42,]),
  result,
  caption = 'Testing Copilot output - ICD9 codes for a respiratory primary diagnosis {#tbl-val}',
  booktabs = TRUE
)
```

We see that the ICD9 values for a respiratory diagnosis checks out in the output. Also note there is no code $460$ (a common cold diagnosis).

### Missing values

Before proceeding to part $2$, we must concede that the complexity of this data is compounded by missing values, which can further confound us by how certain fields are defined. For example:

1.  Is a value reported as "NULL" or "Not Available," or is it simply missing? We can use a mosaic plot to explore missing values for `admission_type` against `age` for more nuanced insights.

2.  Does the absence of data in certain fields impact our analysis? For example, while `diag_2` and `diag_3` may be missing, having a value for `diag_1` (the primary diagnosis) may mitigate their impact on our inquiries. We will ask Copilot to help us investigate these three diagnoses and their missing values.

Let's implement the above, using Copilot's recommendations for the second question.

![](missing_diag.png)

```{r}
#| label: Chunk4
#| warning: false
#| code-fold: true
#| code-summary: "Show the code for plot 1"

# --------------------------------------------- #
# 1) Missing value vs NULL for admission type
# --------------------------------------------- #
p <- D %>% group_by(admission_type, age) %>% 
  summarise(n=n()) %>% mutate(freq = n / sum(n)) 

ggplot(p, aes(x=age, y=admission_type)) + geom_tile(aes(fill=n)) + 
  scale_fill_gradient(low="white", high="blue", labels=function(n) scales::comma(abs(n))) +
  labs(title="Plot 1: Admission type vs Age - examining missing values") + 
  theme(plot.title = element_text(size=14, color="black", hjust = 0.5)) + 
  geom_text(aes(label = scales::comma(n)), size=3, color="gray")

```

```{r}
#| label: Chunk5
#| warning: false
#| code-fold: true
#| code-summary: "Show the code for plot 2"

# --------------------------------------------- #
# 2) Missing values for diagnoses
# --------------------------------------------- #

missing_diag <- D %>%
  select(diag_1, diag_2, diag_3) %>%
  summarise(across(everything(), ~ sum(. == "?"))) %>%
  pivot_longer(cols = everything(), names_to = "Diagnosis", values_to = "Missing") %>%
  mutate(Diagnosis = factor(Diagnosis, levels = c("diag_1", "diag_2", "diag_3")))

ggplot(missing_diag, aes(x = Diagnosis, y = Missing)) +
  geom_bar(stat = "identity", fill = "#56B4E9", color="black") +
  labs(x = "", y = "Number of Missing Values") + theme_minimal() + 
  labs(title="Plot 2: Diagnoses - examining missing values") + 
  theme(plot.title = element_text(size=14, color="black", hjust = 0.5)) + 
  scale_y_continuous(labels = function(n) scales::comma(abs(n)))
```

Here are a few notes on these plots (click on "Show the code .." above each plot for more details) –

1.  In plot 1, its useful to see the missing value pattern, via `NULL`, `Not Available` and `Not Mapped` values. Also, by plotting `admission_type` against `age`, we can see encounters where the data was the most dense, e.g. emergency admissions for the $70-80$ year age group.

2.  In plot 2, we see how `diag_1` has close to no missing values, which is helpful since the primary diagnosis in the encounter will be an important factor in shaping patient care response variables.

> ***Notes on Copilot:** For the missing value analysis of the diagnosis fields in plot* $2$*, I appreciate the utility of `pivot_longer` and `across(everything())`, two tidy functions I have not previously utilized, here recommended by Copilot. The synergy between our analytical vision and Copilot's assistance significantly enhances our productivity. Note that I did modify the Copilot recommendation quite a bit for the visualization, adding `labels = function(n) scales::comma(abs(n))` to neatly format numbers; its a function I have used repeatedly for many years for an easier review of graphics that display numbers.*

## Conclusion and a glimpse into part 2

Healthcare data holds immense potential to enhance patient outcomes, making the ability to navigate complex datasets an invaluable skill for the future. In this post, we introduced a diabetes patient encounter data set, demonstrating how to preprocess it for analysis and highlighting key response variables and covariates that will be explored in part $2$. While we occasionally leveraged Copilot for assistance, precise prompts were essential for effective results.

Thus, in the upcoming part $2$, we will delve into three critical response variables (see @tbl-ex): *early readmission*, specifically investigating the factors influencing readmission within $30$ days of discharge; *diabetes medication prescriptions* during hospital encounters; and any *change in medications*. Our analysis will prioritize correlation over causation, continuing to use `ggplot2` and `dplyr` to extract meaningful insights from the data.

We will closely examine the following relationships:

1.  *A1c test* and *early readmission*

2.  *A1c test* and *medication prescription*

3.  *A1c test* and *medication changes*

Here, the *A1c test* is defined as a binary indicator of whether this vital assessment was conducted. This analysis is pivotal for understanding patient management and hospital readmission, ultimately contributing to improved patient care outcomes. Stay tuned for more!

> ***Some more tips on Copilot in RStudio:***
>
> 1.  *Take a look at Posit's [guide](https://docs.posit.co/ide/user/ide/guide/tools/copilot.html) on how to integrate GitHub Copilot into RStudio, especially where they describe the most effective way to use it while working within RStudio –*
>
>     -   *Code suggestions are typically most useful when applied to a well-scoped and specific problem. When trying to solve larger problems or write longer functions, it is best to break the problem down into smaller pieces and use Copilot and your own expertise to generate code for each chunk. Similar to how a chef might use a recipe to cook each dish that makes up a larger meal, Copilot can be used to generate code for smaller pieces of a larger problem.*
>
> 2.  *When starting to use Copilot for the first time within RStudio, try asking it simpler questions to get used to its completions, e.g.*
>
>     -   *`# summarize the data`*
>
>     -   *`# plot glucose vs bmi in a scatterplot`*
>
> 3.  *You can also begin writing a piece of code and allow Copilot to finish it via autocomplete, e.g.*

![](autocomplete.png){width="498"}


## About the Author

*Vidisha writes: "I am a statistician and data science professional. For practitioners like me 'tidyverse' is a household word. I’ve used it for complex data wrangling, visualization and advanced analytics work, especially where I needed clarity on how to leverage my data so that it allows for story-telling that informs business decisions, recasting my work into actionable insights. I recently began exploring GPT-4o mini and GitHub Copilot to help me speed up my workflows, especially within Healthcare Analytics. I am excited to share this post series to help readers understand the role of RStudio and AI in Healthcare Analytics!"*

