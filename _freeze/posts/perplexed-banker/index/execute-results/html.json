{
  "hash": "e447ec2bcadfb7415e4616cd89df8138",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"The Perplexed Banker\"\nauthor: \"Nina Zumel\"\ndate: 2024-12-20\ndescription: \"A man went into a bank with 1,000 silver dollars and 10 bags. He said, 'Place this money, please, in the bags in such a way that if I call and ask for a certain number of dollars you can hand me over one or more bags, giving me the exact amount called for without opening any of the bags.'\"\nimage: \"georgio_de_chirico.jpg\"\nimage-alt: \"The Perplexed Banker Problem\"\ncategories: \"Puzzle Corner\"\n---\n\n\n\n\n\nFrom Henry Dudeney's \"Perplexities\" article in the March 1925 issue of *The Strand Magazine*:\n\n> A man went into a bank with 1,000 silver dollars and 10 bags. He said, \"Place this money, please, in the bags in such a way that if I call and ask for a certain number of dollars you can hand me over one or more bags, giving me the exact amount called for without opening any of the bags.\" How was it to be done? We are, of course, only concerned with a single application, but he may ask for any exact number of dollars from 1 to 1000.\n\n(In the original article it was \"sovereigns\" and \"pounds\"---but I'm in the U.S., so...)\n\nThis is similar in spirit to [Bachet's Four Weights Problem](https://rworks.dev/posts/four-weights/), so if you've solved that one, you should certainly be able to solve this one.\n\nThe solution is below de Chirico's *The Mathematicians*. \n\n![The Mathematicians, de Chirico (1917)](the-mathematicians-1917.jpg){fig-alt=\"The Mathematicians, de Chirico (1917) source: WikiArt\"}\n\n## The Solution\n\nUnlike the weights problem, the combination of bags here is strictly additive:\n\n$$\n\\sum_{i=1}^{10} s_i b_i = x\n$$\n\nwhere $b_i$ is the number of coins in bag $i$, and $s_i \\in \\{0, 1\\}$.\n\nSo instead of a trinary system, we have a good old binary system. This means if we have $n$ bags and we \nput 1 coin in the first bag, 2 coins in the second bag, 4 coins in the second bag.... That is,\nwe put $2^{i-1}$ coins in the `i`th bag, we can represent any value\nbetween 0 and $2^{n}-1$.\n\nLet's show that with 3 bags, which should give us the numbers 0:7.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# fill the bags\nbags = vapply(1:3, function(i) {2^(i-1)}, numeric(1))\nbags\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 4\n```\n\n\n:::\n\n```{.r .cell-code}\n# get all the possible combinations of bags\nsigns = c(0,1)\nS = expand.grid (s1 = signs,\n                 s2 = signs,\n                 s3 = signs) |>\n  as.matrix()\n\nS\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     s1 s2 s3\n[1,]  0  0  0\n[2,]  1  0  0\n[3,]  0  1  0\n[4,]  1  1  0\n[5,]  0  0  1\n[6,]  1  0  1\n[7,]  0  1  1\n[8,]  1  1  1\n```\n\n\n:::\n\n```{.r .cell-code}\n# get the total number of coins for each combination\nas.numeric(S %*% bags)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 1 2 3 4 5 6 7\n```\n\n\n:::\n:::\n\n\n\nWe have 10 bags, so we can represent any value from 0 to $2^{10} - 1 = 1023$, which is more coins than we have.\nThe 10th bag should hold $2^9 = 512$ coins, but since we are 23 coins short, it will only hold $512-23=489$ coins.\n\nSo the solution is: **The first 9 bags hold $2^{i-1}$ coins for $i$ from 1 to 9; and the last bag holds 489 coins.**\n\n\nLet's verify that.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# fill the bags\nbags = vapply(1:10, function(i) {2^(i-1)}, numeric(1))\nbags[10] = 489 # the last bag is a little short.\n\n# get all the possible combinations of bags\nslist = lapply(1:10, function(i) signs)\nnames(slist) = paste0(\"bag\", 1:10)\n\nS = expand.grid (slist) |> as.matrix()\ndim(S)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1024   10\n```\n\n\n:::\n:::\n\n\n\nNote that there are still 1024 combinations of bags; we know that we can only represent the numbers 0:1000, so some of the totals will be duplicated. In other words, for some numbers, there are multiple combinations of bags that give the same sum.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get the total number of coins for each combination\nx = as.numeric(S %*% bags)\n\n# find all the unique values we can achieve\nx_unique = sort(unique(x))\n\n# confirm that this gives us every value from 0 to 1000\nstopifnot(x_unique==0:1000)\n```\n:::\n\n\n\nSo we have achieved the customer’s ask, and the banker is no longer perplexed!\n\nWe can go a little further. Which sums can be achieved multiple ways?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[duplicated(x)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507\n[20] 508 509 510 511\n```\n\n\n:::\n:::\n\n\n\nNote that 489 is the number of coins in bag10, and 511 is $2^9 - 1$, which, in a proper binary representation, is the last number that wouldn't require bag10 to fulfill the sum.\n\nFor fun, let’s see the different ways to achieve x = 500:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nix = which(x==500)\n\nS[ix, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     bag1 bag2 bag3 bag4 bag5 bag6 bag7 bag8 bag9 bag10\n[1,]    0    0    1    0    1    1    1    1    1     0\n[2,]    1    1    0    1    0    0    0    0    0     1\n```\n\n\n:::\n:::\n\n\n\nThe first solution is the \"standard\" solution, meaning 500 encoded in binary (backwards). The second solution is because our last bag doesn't have the correct number of coins in it, and in fact contains fewer than 500 coins. You can tell it's not the standard answer because we use bag 1, meaning the answer appears to be odd. But this evens out, because bag10 has an odd number of coins in it.\n\n*Nina Zumel is a data scientist based in San Francisco, with 20+ years of experience in machine learning, statistics, and analytics. She is the co-founder of the data science consulting firm Win-Vector LLC, and (with John Mount) the co-author of Practical Data Science with R, now in its second edition.*\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}