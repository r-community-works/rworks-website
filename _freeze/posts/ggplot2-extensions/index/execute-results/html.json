{
  "hash": "cc1caf3209d00f3c028eaeb7f50c7d01",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Speak your plot into existence by writing your own ggplot2 extension\"\nauthor: \"Isabella Velásquez\"\ndate: 2025-06-12\neditor: source\ndescription: \"The ggextenders club provides inspiration and resources for those venturing into the exciting world of creating custom ggplot2 extensions.\"\nimage: ggextenders-hex.png\nimage-alt: \"ggextenders hex showing the image of a cat stretching\"\npage-layout: article\nformat:\n  closeread-html:\n    cr-style:\n      narrative-background-color-overlay: transparent\n      narrative-background-color-sidebar: transparent\n      section-background-color: transparent\n      narrative-text-color-overlay: black\n    theme: [cosmo, styles.css]\n---\n\nIf you use ggplot2, you are probably used to creating plots with `geom_line()` and `geom_point()`. You may also have ventured into to the broader ggplot2 ecosystem to use geoms like `geom_density_ridges()` from [ggridges](https://wilkelab.org/ggridges/) or `geom_signif()` from [ggsignif](https://const-ae.github.io/ggsignif/). But have you ever wondered _how_ these extensions were created? Where did the authors figure out how to create a new geom? And, if the plot of your dreams doesn't exist, how would you make your own?\n\nEnter the exciting world of creating your own ggplot2 extensions.\n\nI had the pleasure of meeting [Gina Reynolds](https://github.com/EvaMaeRey) when I first began my job at Posit (then RStudio) and she was contributing a blog post on [flipbookr](https://evamaerey.github.io/ggplot_flipbook/ggplot_flipbook_xaringan.html#1). Since then, we've kept in touch through the [ggextenders](https://ggplot2-extenders.github.io/ggplot-extension-club/) extension club. Every few months, the club meets virtually to hear from a ggextender (someone who works with ggplot2 extensions). The speaker can talk about a custom geom they've created for the community or more general R visualization topics. Each presentation is insightful and interesting. I've had the opportunity to learn about cool packages like [ggstats](https://larmarange.github.io/ggstats/).  [Join us sometime](https://docs.google.com/forms/d/e/1FAIpQLSe3M1KwUPrmTfEGuuQp0fZ0J7dZkk_82gb310JCvdouMTa_7Q/viewform)!\n\nHowever, I was never a \"ggextender\" myself (having just used and never developed extenders). I found the idea of creating an extension daunting. That is, until recently!\n\nGina held a focus group that worked through the [Easy geom recipes](https://evamaerey.github.io/easy-geom-recipes/), a series of tutorials on creating ggplot2 extensions. Following \"recipes\", you methodically create three extensions. Each time, certain key knowledge points are reinforced and new variations are introduced.\n\nSo, say we want to create a new `geom_*()` that adds a point on the median of the x-axis and y-axis variables of a plot. We will call it `geom_medians()`. Let's follow the recipe:\n\n:::{.cr-section}\n\n## Step 0. Get the job done with 'base' ggplot2.\n\nFirst, clarify what needs to happen without getting into the extension architecture. Load the tidyverse package and the palmerpenguins package. [@cr-step-0a]{highlight=\"1,2\"}\n\nCalculate the median of the x variable (`bill_length_mm`) and y variable (`bill_depth_mm`) as you would normally. [@cr-step-0a]{highlight=\"5,6,7\"}\n\n:::{#cr-step-0a .scale-to-fill}\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(palmerpenguins)\n\n# Compute\npenguins_medians <- penguins |> \n  summarize(bill_length_mm_median = median(bill_length_mm, na.rm = TRUE),\n            bill_depth_mm_median = median(bill_depth_mm, na.rm = TRUE))\n```\n:::\n\n:::\n\nNow, use base ggplot2 to get the job done.[@cr-step02]\n\nThis requires specifying `bill_depth_mm_median` and `bill_length_mm_median`, which we just created, within `aes()` in `geom_point()`.[@cr-step-0b]{highlight=\"7,8\"}\n\n:::{#cr-step-0b .scale-to-fill}\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot\npenguins |> \n  ggplot() + \n  aes(x = bill_depth_mm, y = bill_length_mm) + \n  geom_point() + \n  geom_point(data = penguins_medians,\n             aes(x = bill_depth_mm_median,\n                 y = bill_length_mm_median),\n             size = 8, color = \"red\") + \n  labs(title = \"Created with base ggplot2\")\n```\n:::\n\n:::\n\nThis is the resulting plot.[@cr-step-0c]\n\n:::{#cr-step-0c .scale-to-fill}\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n:::\n\n## Step 1: Define Compute and test.\n\nDefine the compute that will transform your input data \"under the hood\" before rendering it.[@cr-step-1a]\n\n:::{#cr-step-1a .scale-to-fill}\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define compute.\ncompute_group_medians <- function(data, scales){ \n  data |> \n    summarize(x = median(x, na.rm = T),\n              y = median(y, na.rm = T))\n}\n```\n:::\n\n\n:::\n\nNext, test the compute to make sure that the output matches what you expect. Note that the names `x` and `y` are required.[@cr-step-1b]\n\n:::{#cr-step-1b .scale-to-fill}\n\n::: {.cell}\n\n```{.r .cell-code}\n# Test compute. \npenguins |>\n  select(x = bill_depth_mm,  \n         y = bill_length_mm) |>  \n  compute_group_medians()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n      x     y\n  <dbl> <dbl>\n1  17.3  44.4\n```\n\n\n:::\n:::\n\n:::\n\n## Step 2: Define new Stat. Test.\n\nNext, use the `ggplot2::ggproto()` function, which creates a new Stat function that does computation under the hood when building a plot. Don't worry, you don't have to write this yourself. This is provided as boilerplate code, all you have to do is edit the relevant code![@cr-step-2a]\n\n:::{#cr-step-2a .scale-to-fill}\n\n::: {.cell}\n\n```{.r .cell-code}\nStatMedians <-\n  ggplot2::ggproto(\n    `_class` = \"StatMedians\",\n    `_inherit` = ggplot2::Stat,\n    compute_group = compute_group_medians,\n    required_aes = c(\"x\", \"y\")\n  )\n```\n:::\n\n:::\n\nTest your new Stat by using it in a `geom_*()` function.[@cr-step-2b]{highlight=\"6\"}\n\n:::{#cr-step-2b .scale-to-fill}\n\n::: {.cell}\n\n```{.r .cell-code}\npenguins |> \n  ggplot() + \n  aes(x = bill_depth_mm,\n      y = bill_length_mm) + \n  geom_point() + \n  geom_point(stat = StatMedians, size = 7) + \n  labs(title = \"Testing StatMedians\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n:::\n\n## Step 3: Define user-facing functions. Test.\n\nNow, define the user-facing function. This is more boilerplate code that you edit depending on what you are creating.[@cr-step-3a]\n\nThe `stat_*()` function name derives from the Stat objects’s name, but is snake case.[@cr-step-3a]{highlight=\"1\"}\n\n\"Point\" is specified as the default for the geom argument in the function. This means that the ggplot2::GeomPoint will be used in the layer unless otherwise specified by the user.[@cr-step-3a]{highlight=\"3\"}\n\n`StatMedians` defines the new layer function, so summarizing the medians will be in play before the layer is rendered.[@cr-step-3a]{highlight=\"6\"}\n\n:::{#cr-step-3a .scale-to-fill}\n\n::: {.cell}\n\n```{.r .cell-code}\nstat_medians <- \n  function(mapping = NULL, data = NULL, \n           geom = \"point\", position = \"identity\", \n           ..., show.legend = NA, inherit.aes = TRUE) \n    {\n    layer(data = data, mapping = mapping, stat = StatMedians, \n          geom = geom, position = position, show.legend = show.legend, \n          inherit.aes = inherit.aes, params = rlang::list2(na.rm = FALSE, \n                                                           ...))\n    }\n```\n:::\n\n:::\n\nBut alternatively the new `make_constructor()` function, available in ggplot2 v4.0.0, will write much of the above boilerplate code written for you.[@cr-step-3a-1]{highlight=\"6\"}\n\n:::{#cr-step-3a-1 .scale-to-fill}\n\n::: {.cell}\n\n```{.r .cell-code}\nstat_medians <- make_constructor(StatMedians, geom = \"point\")\n\n## check the new function's specification\nprint(stat_medians)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (mapping = NULL, data = NULL, geom = \"point\", position = \"identity\", \n    ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) \n{\n    layer(mapping = mapping, data = data, geom = geom, stat = \"medians\", \n        position = position, show.legend = show.legend, inherit.aes = inherit.aes, \n        params = list2(na.rm = na.rm, ...))\n}\n<environment: 0x11be032a8>\n```\n\n\n:::\n:::\n\n\n\n:::\n\nAnd because users are more accustomed to using layers that have the ‘geom’ prefix, you might also define geom with almost identical properties using `make_constructor`.[@cr-step-3b]  The difference between `stat_medians` and `geom_medians` is that the `stat` is fixed in the former, and the `geom` is fixed in the latter.\n\n:::{#cr-step-3b .scale-to-fill}\n\n::: {.cell}\n\n```{.r .cell-code}\ngeom_medians <- make_constructor(GeomPoint, stat = \"medians\")\n\n## check the new function's specification\nprint(geom_medians)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (mapping = NULL, data = NULL, stat = \"medians\", position = \"identity\", \n    ..., na.rm = FALSE, show.legend = NA, inherit.aes = TRUE) \n{\n    layer(mapping = mapping, data = data, geom = \"point\", stat = stat, \n        position = position, show.legend = show.legend, inherit.aes = inherit.aes, \n        params = list2(na.rm = na.rm, ...))\n}\n<environment: 0x11c103cf0>\n```\n\n\n:::\n:::\n\n:::\n\nNow, test your user-facing function by using it in a ggplot2 plot.[@cr-step-3c]{highlight=\"6\"}\n\n:::{#cr-step-3c .scale-to-fill}\n\n::: {.cell}\n\n```{.r .cell-code}\n## Test user-facing.\npenguins |>\n  ggplot() +\n  aes(x = bill_depth_mm, y = bill_length_mm) +\n  geom_point() +\n  geom_medians(size = 8)  +\n  labs(title = \"Testing geom_medians()\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n:::\n\n:::\n\nAnd then you're done! You've created your first ggplot extension 🥳.\n\nGoing through the recipes is a great way to ease into your ggplot2 extension journey. They offer three well-crafted examples with a clear structure and sequence of steps. The boilerplate code looks daunting, but you can copy/paste it and edit it depending on what you are creating; if you want to go into more detail as to what it's actually doing, the tutorials provide additional resources A fun note is that the geom recipes website uses [webR](https://docs.r-wasm.org/webr/latest/) and [Quarto Live](https://github.com/r-wasm/quarto-live) to embed interactive code chunks directly in the tutorial. It makes for an immersive experience while going through the exercises.\n\nWant to try your own hand at creating `geom_means()`? Go through the interactive tutorial in [Easy geom recipes](https://evamaerey.github.io/easy-geom-recipes/recipe1means.html#your-turn-write-geom_means)!\n\n## Resources\n\nIt's a delight going through Gina's resources, from seeing the [adorable ggextenders hex](https://evamaerey.github.io/everyday_ggplot2_extension/community.html) to reading all the touching notes about ggplot2, comparing it to art, food, poetry, and more. It's a testament to how a tool can inspire so many. Here are some of my favorites quotations and metaphors:\n\n* \"ggplot2 lets users 'speak their plots into existence'\" --- Thomas Lin Pedersen\n* \"You are a composer of ‘graphical poems’\" --- Hadley Wickham\n\nLearn more about Gina's work here:\n\n* [ggplot2 extenders club website](https://ggplot2-extenders.github.io/ggplot-extension-club/): See previous talks and sign up for future webinars\n* [Everyday ggplot2 extension](https://evamaerey.github.io/everyday_ggplot2_extension/): Education materials for potential extenders \n* [ggplot2 extension cookbook](https://evamaerey.github.io/ggplot2-extension-cookbook/): Guide that presents extension strategies in a consistent and accessible way\n* [Easy geom recipes](https://evamaerey.github.io/easy-geom-recipes/): A series of tutorials on creating a tutorial\n\nThere is a comprehensive [list of resources on the ggplot2 extenders club website](https://ggplot2-extenders.github.io/ggplot-extension-club/additional-resources.html).\n\nMany thanks to Andrew Bray, James Goldie, and the QMD Lab for [Closeread](https://closeread.dev/), a Quarto extension for scrollytelling, which walked through the ggextender steps!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}