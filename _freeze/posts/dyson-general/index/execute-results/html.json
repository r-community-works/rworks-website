{
  "hash": "7311d468b6f1e0754126158532d40e06",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Dyson's Algorithm: The General Case\"       \nauthor: \"Nina Zumel\"\ndate: 2025-01-24\nhtml:\n    code-fold: true\n    code-summary: \"Show the code\"\neditor: source\ndescription: \"In a previous post, I described The Twelve Coins Problem, a notoriously hard problem that comes in many flavors and was popular on both sides of the Atlantic during World War II. In this post, I show how to build on Freeman Dyson's solution to solve a generalization of the problem.\"\nimage: \"golden-scale.jpeg\"\nimage-alt: \"Old-School Golden scale in balance with a hand putting a coin on it\"\ncategories: \"Puzzle Corner\"\nbibliography: references.bib\n---\n\n\n\n\n![Photo by Marco Verch, CC-2.0. <a href=\"https://foto.wuestenigel.com/old-school-golden-scale-in-balance-with-a-hand-putting-a-coin-on-it/\">Source</a>](golden-scale.jpeg){fig-alt=\"Old-School Golden scale in balance with a hand putting a coin on it\" fig-align=\"center\"}\n\nIn a [previous post](https://rworks.dev/posts/dysons-algorithm/), we looked at Dyson's algorithm [@dyson] for solving the $M$ Coins in $n$ Weighings problem : \n\n> You have $M$ coins, to appearance exactly identical; but possibly one is counterfeit (we’ll call it a “dud”). You do not know if a dud is present, nor whether it is heavier or lighter than the good coins. Can you determine in $n$ weighings on a balance scale: (1) whether there is a dud, (2) if so, which coin, and (3) its relative weight (lighter or heavier than the good coins)?\n\nThe most famous version of this problem is to resolve 12 coins in 3 weighings; this is an instance of the special case where $M = (3^n - 3)/2$, which is the maximum number of coins that can be resolved in $n$ weighings. The version of the algorithm we showed in the previous post solved exactly this case. In this post, we will adjust that algorithm to the more general case where $3 \\leq M \\leq (1/2)(3^n-3) = M_{max}$. \n\n## Sketch of the Special Case Algorithm\n\nYou probably want to review the previous post before moving on to this one, but I'll quickly sketch the special-case algorithm here. \n\n* First, number the coins from `1:M`. Then assign each coin a label that corresponds to either the signed trinary representation of its number, or the negation of that number, depending on which representation rotates \"forward\" (defined to mean that the first change of digits increases by 1, modulo 3). \n* Next, determine a \"weighing schedule\": which coin goes where for each weighing. The position of each coin on the $i$th weighing is determined by its $i$th digit (starting from the left): $-1$ means the left pan, $1$ means the right pan, and $0$ means the table. \\\n* Similarly, we record the outcome of each weighing by which pan is heavier (if any): $-1$ means the left pan is heavier, $1$ means the right pan is heavier, $0$ means the scale is balanced.\n\nAs we showed in the last post, if the $k$th coin is a heavy dud, it will spell out its own label in signed trinary, \nas $[a_1 a_2 ... a_n]$. A light dud will spell out the negation of the label. \n\nYou can recover the decimal representation of the final outcome, as \n\n$$\nA = \\sum_{i=1}^n {3^{n-i} a_i}\n$$\n\nThen the location of the dud is $|A|$, and the dud is heavy if $[a_1 a_2 ... a_n]$ rotates forward, and it is light if \n$[a_1 a_2 ... a_n]$ rotates backward. If there is no dud, then $A = 0$.\n\n\n## The General Case \n\nThe general case algorithm works basically the same way, but now the coin labels do not correspond directly to the coin numbers (which are still `1:M`). Instead, they are assigned from groups of \"weighing triplets,\" or cyclic groups, in a way that keeps the scale counts equal on the first round.\n\nWe can then use the same weighing schedule as in the $M = M_{max}$ case, with a little extra bookkeeping to keep the scale counts equal on every round. As before, the scale will spell out the label of the dud coin if the dud is heavy, or the label's negation, if the dud is light.\n\nTo make this concrete, we'll use the example of $n = 3$ weighings, but now we want to resolve fewer than 12 coins. You can find the code I'm calling in this example [here](~/dyson_signed_general.R). (**todo: update this link**)\n\nLet's look again at the forward representations for 12 coins. \n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nsource(\"dyson_signed_general.R\")\nlibrary(poorman) # dplyr will work here, too\n\nnrounds = 3\nFmat = get_forward_representation(nrounds)\nFmat\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3]\n [1,]    0    0    1\n [2,]    0    1   -1\n [3,]    0    1    0\n [4,]    0    1    1\n [5,]    1   -1   -1\n [6,]    1   -1    0\n [7,]    1   -1    1\n [8,]   -1    0    1\n [9,]   -1    0    0\n[10,]   -1    0   -1\n[11,]    1    1   -1\n[12,]   -1   -1    0\n```\n\n\n:::\n:::\n\n\n\nIn the above, the row numbers of the matrix are the coin numbers. When we are resolving 12 coins, the forward representations of the coin numbers give the labels for each coin.\n\n**1. Create \"weighing triplets\".**\n\nWhen we want to resolve fewer than 12 coins, the coin number and the forward representations no longer directly correspond. We have to assign the labels as follows.\n\nWe'll start with the label `[0 0 1]`, and increase each digit by 1 modulo 3, to get a new forward label, `[1 1 -1]`. We'll call this a *cyclic shift*. Then we'll take the new label, and shift it again to make a triplet.\n\n```\ncoin 1: label [0 0 1] (1)\ncoin 2: label [1 1 -1] (11)\ncoin 3: label [-1 -1 0] (12) # -12, actually, but this is the forward representation\n```\n\nThis is the first group (or triplet).\n\nNow get the next unassigned label (`[0 1 -1] = 2`), and make another triplet, and so on, until all the labels are assigned to a group. This results in $M_{max}/3$ groups. For this example, that's 4 groups. You can think of each group as a \"weighing triplet\" because every weighing of those three coins together has one coin on the left, one on the right, and one on the table, every round.\n\nHere are all the possible coin labels, their groups, and the digits of the forward representations.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\ngps = create_cyclic_groups(nrounds)\n\nM_max = (3^nrounds - 3) / 2\ngpmap = data.frame(group = gps, coin_label = 1:M_max)\ngpmap = cbind(gpmap, data.frame(Fmat))\narrange(gpmap, group, coin_label) |> knitr::kable()\n```\n\n::: {.cell-output-display}\n\n\n| group| coin_label| X1| X2| X3|\n|-----:|----------:|--:|--:|--:|\n|     1|          1|  0|  0|  1|\n|     1|         11|  1|  1| -1|\n|     1|         12| -1| -1|  0|\n|     2|          2|  0|  1| -1|\n|     2|          6|  1| -1|  0|\n|     2|          8| -1|  0|  1|\n|     3|          3|  0|  1|  0|\n|     3|          7|  1| -1|  1|\n|     3|         10| -1|  0| -1|\n|     4|          4|  0|  1|  1|\n|     4|          5|  1| -1| -1|\n|     4|          9| -1|  0|  0|\n\n\n:::\n:::\n\n\n\nNote that the groups can be precompiled, if you know $n$.\n\n**2. Assign labels to the coins**\n\nNow, if you have $M$ coins, $M < M_{max}$, instead of assigning them sequential labels, you assign them labels from each group, in order. The first 3 coins get labels from the first group, the next 3 from the second group, and so on. You will\nhave $rem = M \\mod 3$ coins left over. If $rem=2$, assign the last two coins to the members of the next group that start with the digits `-1` and `1`; if $rem=1$, then assign the last coin to the member of the next group that starts with `0`.\n\nLet's try some examples. The first group has the labels `(1, 11, 12)`, and the second group has the labels `(2, 6, 8)`.\nSuppose we have 5 coins. Then we'd assign the first three coins the labels 1, 11, 12, and the last two coins\nthe labels 6 (`[1 -1 0]`) and 8 (`[-1 0 1]`). \n\n```\ncoin 1: label [0 0 1] (1)\ncoin 2: label [1 1 -1] (11)\ncoin 3: label [-1 -1 0] (12) \ncoin 4: label [1 -1 0] (6)\ncoin 5: label [-1 0 1] (8)\n```\n\nIf we have 4 coins, we'd assign the first three coins the labels 1, 11, 12, and the last coin the label 2 (`[0 1 -1]`).\n\n```\ncoin 1: label [0 0 1] (1)\ncoin 2: label [1 1 -1] (11)\ncoin 3: label [-1 -1 0] (12) \ncoin 4: label [0 1 -1] (2)\n```\n\n**3. Weigh the coins according to the weighing schedule.**\n\nThe weighing schedule is the same as it was before, but now we're only using some of the labels.\nEach coin is placed on the scale according to the digits of its label.\nHere's the weighing schedule for the first weighing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nCset = compileC(Fmat)\nknitr::kable(Cset[[1]])\n```\n\n::: {.cell-output-display}\n\n\n| left| table| right|\n|----:|-----:|-----:|\n|    8|     1|     5|\n|    9|     2|     6|\n|   10|     3|     7|\n|   12|     4|    11|\n\n\n:::\n:::\n\n\n\nSo the first weighing of five coins is as follows:\n\n```\ncoin1 (1): table\ncoin2 (11): right\ncoin3 (12): left\ncoin4 (6): right\ncoin5 (8): left\n\n[ {coin3, coin5} | {coin2, coin4} ]\n------------------------------------\ncoin1\n```\n\nThis time, in addition to keeping track of the weighing outcome $a_i$, we also need to keep track of which coins we know to be good, based on the outcome of the weighing. We know that \n\n* if the scale is balanced, then all the coins on the scale are good (the dud is on the table), and \n* if the scale is not balanced, then all the coins on the table are good (the dud is on the scale).\n\nLet's suppose the scale tilts right (`a[1] = 1`). Then we know that `coin1` is good. Now, to the second weighing:\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nknitr::kable(Cset[[2]])\n```\n\n::: {.cell-output-display}\n\n\n| left| table| right|\n|----:|-----:|-----:|\n|    5|     1|     2|\n|    6|     8|     3|\n|    7|     9|     4|\n|   12|    10|    11|\n\n\n:::\n:::\n\n\n\n```\ncoin1 (1, good): table\ncoin2 (11): right\ncoin3 (12): left\ncoin4 (6): left\ncoin5 (8): table\n\n[{coin3, coin 4} | {coin2} ]\n------------------------------\ncoin1, coin5\n```\n\nOops! Now, the scale counts aren't equal. But we know that `coin1` is good, so we can put it in the right pan to equalize the coin counts without affecting the outcome.\n\n```\n[{coin3, coin 4} | {coin2, coin1} ]\n------------------------------\ncoin5\n```\n\nSometimes the scale count isn't equal, but none of the coins on the table have been marked good. In that case, find a good coin in the pan with more coins and put it on the table.\n\nTo continue the example, let's say that the scale again tilts right (`a[2] = 1`). Now we know that `coin5` is good.\nOn to weighing three.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nknitr::kable(Cset[[3]])\n```\n\n::: {.cell-output-display}\n\n\n| left| table| right|\n|----:|-----:|-----:|\n|    2|     3|     1|\n|    5|     6|     4|\n|   10|     9|     7|\n|   11|    12|     8|\n\n\n:::\n:::\n\n\n\n```\ncoin1 (1, good): right\ncoin2 (11): left\ncoin3 (12): table\ncoin4 (6): table\ncoin5 (8, good): right\n\n[{coin2} | {coin1, coin5}]\n---------------------------\ncoin3, coin4\n\nMove either of coin1 or coin5 to the table.\n\n[ {coin2} | {coin1} ]\n-----------------------\ncoin3, coin4, coin5\n```\n\nNow, this time, the scale tilts left (`a[3] = -1`). We have `a = [1 1 -1]`, which means $A = 9 + 3 - 1 = 11$. \nThe label 11 corresponds to `coin2`, and `a` rotates forward, so the dud is `coin2` and is heavy.\n\nLet's confirm that with code. As before, the function `find_dud` returns a value `D` such that `abs(D)` gives the index of the dud, and `sign(D)` gives the dud's relative weight: negative means the dud is light, and positive means the dud is heavy.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nnrounds = 3\nncoins = 5\ncoins = numeric(ncoins) + 1 # good coins weigh 1 unit\n\n# precompilation computes both\n# the weighing schedule and the label groups\nprecompiled = precompile(nrounds)\n\n# make coin 2 a heavy dud\ncoins[2] = 1.5\nfind_dud(coins, precompiled)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2\n```\n\n\n:::\n:::\n\n\n\nWe'll try 10 coins.\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\nncoins = 10\ncoins = numeric(ncoins) + 1\n\n# no dud case\nfind_dud(coins, precompiled)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"No dud.\"\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\n# 7, light\ncoins[7] = 0.5\nfind_dud(coins, precompiled)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] -7\n```\n\n\n:::\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\n# confirm all possible cases work\nfor(icoin in 1:ncoins) {\n  for (direction in c(-1, 1)) {\n    coins = numeric(ncoins) + 1\n    coins[icoin] = 1 + 0.5 * direction\n    actual = icoin * direction\n    result = find_dud(coins, precompiled)\n    stopifnot(actual == result)\n  }\n}\n```\n:::\n\n\n\nThis generalizes Dyson's algorithm. It's not as pretty as the special case version, but it works. \n\n*Nina Zumel is a data scientist based in San Francisco, with 20+ years of experience in machine learning, statistics, and analytics. She is the co-founder of the data science consulting firm Win-Vector LLC, and (with John Mount) the co-author of Practical Data Science with R, now in its second edition.*\n## References\n\n::: {#refs}\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}