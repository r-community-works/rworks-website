{
  "hash": "ab5f29f801741596d8d07d6c24eb22eb",
  "result": {
    "markdown": "---\ntitle: \"Digital Difficulties\"\nauthor: \"Nina Zumel\"\ndate: 2025-03-14\ndescription: \"\"\nimage: \"Original-Odhner-Arithmos-Typ-5.png\"\nimage-alt: \"Original-Odhner-Arithmos-Typ-5 calculator, circa 1912-1928. Source: Wikipedia\"\ncategories: \"Puzzle Corner\"\n---\n\n\nHere's another puzzle, from Henry Dudeney's [*Perplexities* column](https://babel.hathitrust.org/cgi/pt?id=mdp.39015055410677&seq=115) in *Strand Magazine*, January 1924.\n\n> Arrange the ten digits, 1 2 3 4 5 6 7 8 9 0, in such order that they shall form a number \nthat may be divided by every number from 2 to 18 without in any case a remainder. As an example, \nif I arrange them thus: 1 2 7 4 9 5 3 6 8 0, this number can be divided by 2,3,4,5, and so on up to 16,\nwithout any remainder, but it breaks down at 17.\n\nOne of the additional challenges in taking puzzles from these older sources is to try to solve them\nthe way a puzzle-solver would have, back in 1924. In this case, I wasn't successful at finding a pure paper-and-pencil solution,\nbut I did find an elegant modern solution that would have been possible with the computational machines of the era.\n\nBut before I show you my solution, try it yourself, first! My solution after *The Mathematicians*.\n\n![The Mathematicians, Chirico (1917)](the-mathematicians-1917.jpg){fig-alt=\"The Mathematicians, Chirico (1917) source: WikiArt\"}\n\n\n## Solution\n\nLet's look at a super brute force solution first, and then a more elegant, but still not quite paper-and-pencil one.\n\n### The Brute Force Solution\n\n\n::: {.cell}\n\n:::\n\n\nWith a modern computer, one could simply generate all $10! =$ 3,628,800 possible permutations of the ten digits. \nThen, for each permutation, check whether it is divisible by all the integers from 2 to 18. This is brutal, but it works.\n\nWe can also reduce the number of permutations by taking advantage of some facts about divisibility.\n\nA number is:\n\n* divisible by 10 (and 5) if the last digit is 0\n* divisible by 4 (and 2) if the last two digits are a number divisible by 4 (See the appendix for a quick explanation of why).\n\nCombining these facts, we can deduce that the last two digits of our target number must be 20, 40, 60, or 80.\nThis leaves (for each case), $8! =$ 40,320 permutations, giving us a total of $4 *$ 40320 = 161,280 candidates to examine. That's a much smaller number!\n\n### An Elegant Modern Solution\n\nHere's a solution that reduces the number of candidates even more. This time, we'll start by finding the smallest number, $m$, that is divisible by all the integers from 2 to 18. We know that our target number must be a multiple of $m$. Next, we find all the multiples\nof $m$ in the appropriate range, and check which one(s) have ten unique digits. These will be the solutions. \n\nLet's code this solution up, in R.\n\n#### Find the Least Common Multiple (LCM) of the integers from 2 to 18\n\nWe'll start by multiplying all the primes in our range:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm = 2*3*5*7*11*13*17\nm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 510510\n```\n:::\n:::\n\n\nNote that this number is also divisible by `6=2*3, 10=2*5, 14=2*7`, and `15=3*5`. What factors are left?\nTo save the trouble of tracking this by hand, we'll write a function to return which integers in the range 2:18 a number `m` is *not* divisible by.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnot_divisible_by = function(m) {\n  candidates = 2:18\n  \n  remainders = m %% candidates\n  candidates[remainders != 0]\n}\n\nnot_divisible_by(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  4  8  9 12 16 18\n```\n:::\n:::\n\n\nIf we further multiply $m$ by another 3, it will then be divisible by 9 and 18. If we then also multiply $m$ by 4, it will\nbe divisible by 4, 8, and 12. This leaves 16, which means we need another 2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 3 and 4, first\nm = m*3*4\nnot_divisible_by(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 16\n```\n:::\n\n```{.r .cell-code}\n# now an extra 2\nm = m*2\nnot_divisible_by(m)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ninteger(0)\n```\n:::\n:::\n\n\nThat gives us m = 12252240, which should be the smallest number divisible by all integers from 2 to 18. \nThe number we want must therefore be a multiple of `m`.\n\n#### Filter all the multiples of $m$\n\nNow we need to\n\n* find all the multiples of $m$ in the appropriate range\n* find all the resulting numbers that have ten unique digits\n\nFirst, we'll find the range of candidates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the smallest possible candidate\nminC = 1234567890\n\n# the largest possible candidate\nmaxC = 9876543210\n\n# the range of multipliers to consider\ncrange = round(c(minC, maxC)/m)\ncrange\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 101 806\n```\n:::\n:::\n\n\nThis leaves 706 candidates to check, which is far fewer than 161,280.\nWe already know all these candidates are divisible by all the integers from 2 to 18; we just need to check which ones are a number comprised of ten unique digits.\n\nSo let's write the filter and do the calculation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nten_unique_digits = function(nint) {\n  nstring = as.character(nint)\n  if(nchar(nstring) != 10) return(FALSE)\n  \n  # create a vector of digits\n  digits = unlist(strsplit(nstring, split=\"\"))\n  \n  length(unique(digits)) == length(digits)\n}\n\n\ncandidates = m * crange[1]:crange[2]\ncfilter = vapply(candidates, ten_unique_digits, logical(1))\n\nsolns = candidates[cfilter]\nsolns\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2438195760 3785942160 4753869120 4876391520\n```\n:::\n:::\n\n\nThere are 4 solutions! Let's check manually that all solutions are valid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(s in solns) {\n  print(paste(\"Checking solution\", s))\n  for(i in 2:18) {\n    stopifnot(s %% i == 0)\n  }\n  print(\"--- Checks out\")\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Checking solution 2438195760\"\n[1] \"--- Checks out\"\n[1] \"Checking solution 3785942160\"\n[1] \"--- Checks out\"\n[1] \"Checking solution 4753869120\"\n[1] \"--- Checks out\"\n[1] \"Checking solution 4876391520\"\n[1] \"--- Checks out\"\n```\n:::\n\n```{.r .cell-code}\n# let's also find the multipliers\nsolns/m\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 199 309 388 398\n```\n:::\n:::\n\n\nAnd we are done! âœ…\n\n## But How Would Dudeney Solve This?\n\n\n::: {.cell}\n\n:::\n\n\nIt's easy to find $m$, the LCM of the integers from 2 to 18, with pencil and paper. But I have a hard time imagining that a puzzle-solver in 1924 would be willing to calculate candidate multiples of $m$ by hand to find one with ten unique digits. Even if they started at 101`m` and worked their way up, they would have to check 199 - 101 + 1 = 99 candidates before they find a solution. That doesn't sound fun anymore.\n\nFortunately, even in 1924, a sophisticated puzzle-solver (like Dudeney) might not need to do the calculation purely\nby pencil and paper. They could have used a mechanical calculator of the era, like the [Arithmometer](https://en.wikipedia.org/wiki/Arithmometer) below:\n\n![The Odhner Arithmos, Type 5, circa 1912-1928. Source: [Wikipedia](https://en.wikipedia.org/wiki/File:Original-Odhner-Arithmos-Typ-5.jpg)](Original-Odhner-Arithmos-Typ-5.png)\n\nWith such a device, a puzzle-solver could literally crank out multiples of $m$, scanning each one as they go, rejecting values with repeated digits, until they discover a solution to the puzzle. I imagine it could be done in under ten minutes---which would not be considered a long time for someone accustomed to more manual calculations.\n\nYou can read more about older calculation technologies in John Mount's article, [*Calculating at Pencil and Paper Scale*](https://win-vector.com/2024/11/06/calculating-at-pencil-and-paper-scale/).\n\nOne of the descendants of the Arithmometer is the [Curta calculator](https://en.wikipedia.org/wiki/Curta), and we \nat Win Vector just happen to have one! Solving this problem with a Curta would be much like solving it with an Arithmometer. \nHere's a video of John Mount \"finding\" the smallest solution to the puzzle:\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/KHiS7niRdQI?si=e9sLc6W5nvOz_wzj\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n\nThe discovered solution is in the black area, and the associated multiple of $m$ is in the white area. Keep in mind that John already knew how many cranks he had to do before a solution came up, and after about the first two or three cranks, he stopped checking for duplicate digits. So this is probably a little faster than it would take someone who really didn't know what the answer was.\n\nNow that I know about the Arithmometer and related devices, I'm not too worried about whether Dudeney could have executed my solution. \nBut I do feel sorry for any poor *Strand Magazine* readers who didn't have the latest calculating technology. And I still wonder if I'm missing an even more clever trick, which would have made this solvable with just pencil and paper. If I ever find such a  solution,  I'll post it here at Puzzle Corner. And if you ever find one, please do write in and let us know!\n\n---\n\n## Appendix: Divisibility by 4\n\n**A number is divisible by 4 if its last two digits are divisible by 4.**\n\nLet $N$ be the original number, and $n$ be the number formed by the last two digits.\nThen $N - n$ is a number that is divisible by 100. Since 100 is divisible by 4,\nso is $N-n$. Therefore, $N$ is divisible by 4 if $n$ is.\n\n**Example**:\n\n```\nN = 724\nn = 24\nM = N - n = 700\n```\n\n700 is divisible by 100, therefore divisible by 4. 24 is divisible by 4. Therefore 724 is divisible by 4.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}