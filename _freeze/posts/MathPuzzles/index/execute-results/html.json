{
  "hash": "3d5a50185fae7f053d9c5dbbb75820b0",
  "result": {
    "markdown": "---\ntitle: \"How many ways to color this grid: Combinatorics in R\"\nformat: html\neditor: visual\n---\n\n\nI love solving puzzles of every kind, but being a statistician, I am partial to combinatorics. The other day, I solved one in R, using `dplyr`.\n\n## The Problem\n\nThis is a very simple version of the classic coloring-a-grid problem, and can also be seen as a graph theory puzzle.\n\n> You have a 2x2 grid of squares, and you need to paint each square one of four colors: red, blue, green, or yellow. The restriction is that no two adjacent squares (sharing a side) can have the same color. How many valid ways you can color the grid?\n\n## The Solution\n\nThere are many ways to solve this. In each solution, we count the number of combinations that are \"correct\" or valid, i.e. adhere to the rules given above in the problem. For the solution in R, we will calculate all possible combinations of coloring this grid with no restrictions, and using that, directly count cases which *follow the adjacency rules* specified in the problem.\n\nI will use `dplyr` to illustrate how easy and straightforward it will be to get to the solution.\n\nThe simplest way of calculating ways coloring this grid with no restrictions is to consider that for each of the 4 squares ($n$), there are 4 possible options ($r$, see square above), so that the total number of options we have is essentially â€”\n\n$$\nn^r = 4^4 = 256\n$$\n\nWe now use R to compute these $256$ options.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gtools)\nx <- c('r', 'b', 'g', 'y')\nP <- permutations(n=4,r=4,v=x,repeats.allowed=T) \ncolnames(P) <- c(\"A\",\"B\",\"C\",\"D\")\nP <- data.frame(P)\nnrow(P)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 256\n```\n:::\n\n```{.r .cell-code}\nhead(P)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A B C D\n1 b b b b\n2 b b b g\n3 b b b r\n4 b b b y\n5 b b g b\n6 b b g g\n```\n:::\n:::\n\n\nHow do we now determine which cases do not follow the adjacency rules? To do this, we'll need to use a pattern-searching logic to flag them. One way to do this computationally is to calculate, for all 256 cases, 4 different columns, corresponding to the 4 adjacency restrictions (e.g. red-red, blue-blue, green-green and yellow-yellow). We would then use these 4 columns to compute a single new column flagging cases where adjacency restrictions are followed, i.e. flag *valid* cases, and sum them up.\n\nHowever, in R, using `dplyr`, we combine this in a single command using `case when`, which will flag each case whenever it meets the invalidity condition even once, e.g. for the coloring scheme \"blue-blue-blue-red\", it will flag it \"invalid\" since just the existence of \"blue-blue\" is sufficient to deem this scheme invalid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(magrittr)\ncase_split <- P %>% \n  mutate(concat=paste(P$A, P$B, P$C, P$D, P$A, sep=\"\")) %>%\n  mutate(flag = case_when(grepl(\"rr\", concat) ~ \"invalid\", \n                          grepl(\"bb\", concat) ~ \"invalid\", \n                          grepl(\"gg\", concat) ~ \"invalid\", \n                          grepl(\"yy\", concat) ~ \"invalid\", .default = \"valid\")) %>%\n  group_by(flag) %>% summarise(count=n())\nknitr::kable(case_split, align=rep('c', 2))\n```\n\n::: {.cell-output-display}\n|  flag   | count |\n|:-------:|:-----:|\n| invalid |  172  |\n|  valid  |  84   |\n:::\n:::\n\n\nThere are $84$ valid cases, which can of course be computed arithmetically using combinatorics formulas, or simply going case by case and calculating how many valid cases emerge, which will also give us $84$ valid cases of the total $256$.\n\nOf these remaining $172$ invalid cases, I then thought about how many are so due to not heeding the adjacency rules just once, how many twice or more? For example, \"bbbg\" does not heed it twice, \"bbrg\" just once. To do this, for each of the 256 cases, instead of just the existence of invalidity, we flag each occurence of adjacency or invalidity, and then sum them up.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflag_invalid_adj <- function(df) {\n  df %>%\n    rowwise() %>%\n    mutate(\n      # Check each adjacency pair for invalidity\n      ab_invalid = A == B,\n      bc_invalid = B == C,\n      cd_invalid = C == D,\n      ad_invalid = A == D,\n      # Count the number of invalid pairs\n      invalid = sum(ab_invalid, bc_invalid, cd_invalid, ad_invalid),\n    ) %>%\n    ungroup() \n}\ncols <- P[,1:4]\ninvalid_data <- flag_invalid_adj(cols) %>% select(A, B, C, D, invalid)\nfinalCounts <- invalid_data %>% group_by(invalid) %>% summarise(count=n())\nknitr::kable(finalCounts, align=rep('c', 2))\n```\n\n::: {.cell-output-display}\n| invalid | count |\n|:-------:|:-----:|\n|    0    |  84   |\n|    1    |  96   |\n|    2    |  72   |\n|    4    |   4   |\n:::\n:::\n\n\nFinally, because we can, and we love `ggplot2`, let's generate 1 sample grid from each category of invalidity, so that we can visually inspect what we've been saying. The \"4x invalid\" has 4 pairs of blue, or 4 adjacencies, while the \"0x invalid\" plot is an example of how we can indeed color a graph, map or a grid with 4 colors with no squares having the same color.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\n# Select first row of all groups\ns <- invalid_data %>% group_by(invalid) %>% filter(row_number()==1)\n\n# Load necessary libraries\nlibrary(ggplot2)\nlibrary(gridExtra)  # or library(patchwork)\nlibrary(dplyr)      # For tibble and data manipulation\n\n# Step 1: Create my color tibble (4x4)\nsq <- s %>% \n  mutate_all(~ case_when(\n    . == \"b\" ~ \"blue\",\n    . == \"g\" ~ \"green\",\n    . == \"y\" ~ \"yellow\",\n    . == \"r\" ~ \"red\",\n    TRUE ~ .  # Keep original value if it doesn't match\n  ))\n\n# Step 2: Convert tibble to a matrix\ncolor_matrix <- sq[,-5] %>% select(A,B,D,C) %>% as.matrix() # to match the coloring order of ggplot2\n\n# Check the dimensions of the matrix\n#print(dim(color_matrix))  # Should be 4x4\n\n# Step 3: Function to create a plot based on a color vector and a title\ncreate_plot <- function(colors, title) {\n  df <- expand.grid(x = 0:1, y = 0:1)\n  df$color <- colors\n  \n  ggplot(df, aes(x = x, y = y, fill = color)) +\n    geom_tile(color = \"white\") +  # Change border color to white\n    scale_fill_identity() +        # Use the colors as they are\n    theme_minimal() +              # Use a minimal theme\n    coord_fixed() +                # Keep aspect ratio\n    labs(title = title) +          # Add the title\n    theme(\n      legend.position = \"none\",    # Remove legend\n      axis.title = element_blank(), # Suppress axis titles\n      axis.text = element_blank(),  # Suppress axis text\n      axis.ticks = element_blank(), # Suppress axis ticks\n      panel.grid = element_blank()   # Suppress grid lines\n    )\n}\n\n# Step 4: Create a vector of titles for each plot\ntitles <- c(\"4x invalid\", \n            \"2x invalid\", \n            \"1x invalid\", \n            \"0x invalid\")\n\n# Step 5: Create a list of plots using the color matrix and titles\nplots <- lapply(1:nrow(color_matrix), function(i) {\n  create_plot(color_matrix[i, ], titles[i])\n})\n\n# Step 6: Arrange the plots on one page\ngrid.arrange(grobs = plots, ncol = 2)  # 2 columns\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/Chunk4-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}