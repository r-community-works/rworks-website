{
  "hash": "51524892ae0100b3aa3b61742311c965",
  "result": {
    "markdown": "---\ntitle: \"How many ways to color this grid: teaching Combinatorics using R\"\nauthor: \"Vidisha Vachharajani\"\ndate: 2025-03-21\nformat: html\neditor: source\ndescription: \"A simplified version of the four color theorem: suppose you have a 2x2 grid of squares, and you need to paint each square one of four colors: red, blue, green, or yellow. The restriction is that no two adjacent squares (sharing a side) can have the same color. How many valid ways you can color the grid\"\nimage: \"\"\nimage-alt: \"\"\ncategories: \"Puzzle Corner\"\n---\n\n\n## The Problem\n\n> You have a 2x2 grid of squares, and you need to paint each square one of four colors: red, blue, green, or yellow. The restriction is that no two adjacent squares (sharing a side) can have the same color. How many valid ways you can color the grid?\n\nThis problem is a simplified illustration of the four-color [theorem](https://en.wikipedia.org/wiki/Four_color_theorem), which says that four colors are sufficient to color any planar map such that no two adjacent regions share the same color. Additionally, it can be viewed as a specific case of a more generalized problem: coloring a $K$ x $K$ grid with $N$ colors while adhering to adjacency restrictions. From a graph theory perspective, we can represent this grid as a graph where each square corresponds to a vertex, and edges connect vertices that are adjacent. The challenge of coloring the grid without violating the adjacency rule translates to finding a proper vertex coloring of this graph.\n\n## The Solution\n\nThere are many ways to solve this. In each solution, we count the number of combinations that are \"correct\" or valid, i.e. adhere to the rules given above in the problem. For the solution in R, we will generate all possible combinations of coloring this grid with no restrictions, and using that, directly count cases which *follow the adjacency rules* specified in the problem.\n\nI will use `dplyr` to illustrate how easy and straightforward it will be to get to the solution.\n\nThe simplest way to calculate ways to color this grid with no restrictions is to consider that for each of the $4$ squares ($n$), there are $4$ possible options ($r$, see square above), so that the total number of options we have is essentially —\n\n$$\nn^r = 4^4 = 256\n$$\n\nWe now use R to generate these $256$ cases or options.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(gtools)\nx <- c('r', 'b', 'g', 'y')\nP <- permutations(n=4,r=4,v=x,repeats.allowed=T) \ncolnames(P) <- c(\"A\",\"B\",\"C\",\"D\")\nP <- data.frame(P)\nnrow(P)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 256\n```\n:::\n\n```{.r .cell-code}\nhead(P)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  A B C D\n1 b b b b\n2 b b b g\n3 b b b r\n4 b b b y\n5 b b g b\n6 b b g g\n```\n:::\n:::\n\n\nHow do we now determine which cases do not follow the adjacency rules? To do this, we'll need to use a pattern-searching logic to flag them. One way is to calculate, for all $256$ cases, $4$ different columns, corresponding to the $4$ adjacency restrictions (e.g. red-red, blue-blue, green-green and yellow-yellow). We would then use these $4$ columns to compute a single new column flagging cases where adjacency restrictions are followed, i.e. flag *valid* cases, and sum them up.\n\nHowever, in R, using `dplyr`, we combine this in a single command using `case when`, which will flag each case whenever it meets the invalidity condition even once, e.g. for the coloring scheme \"blue-blue-blue-red\", it will flag it \"invalid\" since just the existence of \"blue-blue\" is sufficient to deem this scheme invalid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(magrittr)\ncase_split <- P %>% \n  mutate(concat=paste(P$A, P$B, P$C, P$D, P$A, sep=\"\")) %>%\n  mutate(flag = case_when(grepl(\"rr\", concat) ~ \"invalid\", \n                          grepl(\"bb\", concat) ~ \"invalid\", \n                          grepl(\"gg\", concat) ~ \"invalid\", \n                          grepl(\"yy\", concat) ~ \"invalid\", .default = \"valid\")) %>%\n  group_by(flag) %>% summarise(count=n())\nknitr::kable(case_split, align=rep('c', 2))\n```\n\n::: {.cell-output-display}\n|  flag   | count |\n|:-------:|:-----:|\n| invalid |  172  |\n|  valid  |  84   |\n:::\n:::\n\n\nThere are $84$ valid cases, which can of course be computed arithmetically using combinatorics formulas, or simply going case by case and calculating how many valid cases emerge, which will also give us $84$ valid cases of the total $256$.\n\nOf these remaining $172$ invalid cases, I then thought about how many are so due to not heeding the adjacency rules just once, how many twice or more? For example, \"bbbg\" does not heed it twice, \"bbrg\" just once. To do this, for each of the $256$ cases, instead of just the existence of invalidity, we flag each occurence of adjacency or invalidity, and then sum them up.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflag_invalid_adj <- function(df) {\n  df %>%\n    rowwise() %>%\n    mutate(\n      # Check each adjacency pair for invalidity\n      ab_invalid = A == B,\n      bc_invalid = B == C,\n      cd_invalid = C == D,\n      ad_invalid = A == D,\n      # Count the number of invalid pairs\n      invalid = sum(ab_invalid, bc_invalid, cd_invalid, ad_invalid),\n    ) %>%\n    ungroup() \n}\ncols <- P[,1:4]\ninvalid_data <- flag_invalid_adj(cols) %>% select(A, B, C, D, invalid)\nfinalCounts <- invalid_data %>% group_by(invalid) %>% summarise(count=n())\nknitr::kable(finalCounts, align=rep('c', 2))\n```\n\n::: {.cell-output-display}\n| invalid | count |\n|:-------:|:-----:|\n|    0    |  84   |\n|    1    |  96   |\n|    2    |  72   |\n|    4    |   4   |\n:::\n:::\n\n\nThe first row confirms the count of $84$ valid cases, i.e. have no adjacency problem. Finally, because we can, and we love `ggplot2`, let's generate 1 sample grid from each category of invalidity, so that we can visually inspect what we've been saying. The \"4 invalid cases\" has 4 pairs of blue, or 4 adjacencies, while the \"No invalid cases!\" plot is an example of how we can indeed color a graph, map or a grid with 4 colors with no adjacent squares or \"regions\", having the same color. Some notes on the code used – we plot the 4 examples using `gridExtra`. We'll also use `textGrob` to attribute an overall title for the family of plots, using an elegant font from the Google library (\"rouge script\"). Click \"Show the code\" to see the details.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Show the code\"}\n# Select first row of all groups\ns <- invalid_data %>% group_by(invalid) %>% filter(row_number()==1)\n\n# Load necessary libraries for elegant visualizations\nlibrary(ggplot2)\nlibrary(grid)       # to ensure \"textGrob\" works\nlibrary(gridExtra)  \nlibrary(showtext)   # For using custom fonts\n\n# Load a font using showtext\nfont_add_google(\"Rouge Script\", \"rouge script\")  # Example: Adding the \"Lobster\" font\nshowtext_auto()  # Automatically use showtext for all plots\n\n# Create my color tibble (4x4)\nsq <- s %>% \n  mutate_all(~ case_when(\n    . == \"b\" ~ \"blue\",\n    . == \"g\" ~ \"green\",\n    . == \"y\" ~ \"yellow\",\n    . == \"r\" ~ \"red\",\n    TRUE ~ .  # Keep original value if it doesn't match\n  ))\n\n# Convert tibble to a matrix\ncolor_matrix <- sq[,-5] %>% select(A,B,D,C) %>% as.matrix() # to match the coloring order of ggplot2\n\n# Check the dimensions of the matrix\n#print(dim(color_matrix))  # Should be 4x4\n\n# Function to create a plot based on a color vector and a title\ncreate_plot <- function(colors, title) {\n  df <- expand.grid(x = 0:1, y = 0:1)\n  df$color <- colors\n  \n  ggplot(df, aes(x = x, y = y, fill = color)) +\n    geom_tile(color = \"white\") +  # Change border color to white\n    scale_fill_identity() +        # Use the colors as they are\n    theme_minimal() +              # Use a minimal theme\n    coord_fixed() +                # Keep aspect ratio\n    labs(title = title) +          # Add the title\n    theme(\n      legend.position = \"none\",    # Remove legend\n      axis.title = element_blank(), # Suppress axis titles\n      axis.text = element_blank(),  # Suppress axis text\n      axis.ticks = element_blank(), # Suppress axis ticks\n      panel.grid = element_blank(),   # Suppress grid lines\n      plot.title = element_text(family = \"rouge script\", size = 16, hjust = 0.5)  # Use the custom font for the title\n    )\n}\n\n# Create a vector of titles for each plot\ntitles <- c(\"4 invalid cases\", \n            \"2 invalid cases\", \n            \"1 invalid case\", \n            \"No invalid cases!\")\n\n# Create a list of plots using the color matrix and titles\nplots <- lapply(1:nrow(color_matrix), function(i) {\n  create_plot(color_matrix[i, ], titles[i])\n})\n\n# Create the overall title using textGrob \noverall_title <- textGrob(\"Using R to elegantly illustrate the solution to a Combinatorics puzzle\", gp = gpar(fontsize = 20, fontfamily = \"rouge script\"))\n\n# Create a spacer with appropriate height\nspacer <- rectGrob(gp = gpar(fill = NA, col = NA), width = unit(1, \"npc\"), height = unit(0.5, \"lines\"))\n\n# Arrange the overall title and plots\ngrid.arrange(overall_title, spacer, \n             arrangeGrob(grobs=plots, ncol = 2), \n             ncol = 1, heights = c(1, 0.1, 4))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/Chunk4-1.png){width=672}\n:::\n:::\n\n\n## About the Author\n\n\n\n*Vidisha writes: \"As a statistician and a data geek, I love solving puzzles of all kinds, with a particular fondness for combinatorial challenges. Recently, I tackled one in R using the dplyr package, which prompted me to think about the broader applications of R, not just as a powerful tool for solving puzzles for enthusiasts, but also as an empowering way to teach high school mathematics. Moreover, R's capabilities in data visualization can help learners grasp complex problems more intuitively, ultimately leading to a deeper understanding of their solutions.\"*\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}