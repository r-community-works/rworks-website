{
  "hash": "2eecabb8c233f6a56dce1d93d9debf78",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"100 Bushels of Corn, Revisited\"\nauthor: [\"John Mount\", \"Nina Zumel\"]\ndate: 2024-11-22\nformat: html\neditor: source\ndescription: \"We find more solutions to the 100 Bushels of Corn puzzle using the numbers R package.\"\nimage: numbers.jpg\nimage-alt: \"Rulers of different fonts and shapes lined up\"\ncategories: \"Puzzle Corner\"\n---\n\n\n\n::: {.callout-note}\n## About the authors\n\nJohn Mount is a data scientist based in San Francisco, with 20+ years of experience in machine learning, statistics, and analytics. He is the co-founder of the data science consulting firm Win-Vector LLC, and (with Nina Zumel) the co-author of Practical Data Science with R, now in its second edition.\n\nNina Zumel is a data scientist based in San Francisco, with 20+ years of experience in machine learning, statistics, and analytics. She is the co-founder of the data science consulting firm Win-Vector LLC, and (with John Mount) the co-author of Practical Data Science with R, now in its second edition.\n:::\n\n## Introduction\n\nNina Zumel presented the \"100 Bushels of Corn\" puzzle [here](https://rworks.dev/posts/100bushels/) as a fun example of using R as a calculator. What if we want R to solve the puzzle for us, instead of merely being a calculator?\n\nLet's give that a go.\n\n## Setting Up the Problem\n\n> 100 bushes of corn are distributed to 100 people such that every man receives 3 bushels, every woman 2 bushels, and every child 1/2 a bushel. How many men, women, and children are there?\n\nWe can write the 100 Bushels of Corn problem as finding integer vectors `x` that satisfy `a %*% x = b` for the following `a, b`. The first row specifies the constraint on the total number of men, women and children; the second row specifies the constraint on how many bushels each person gets. Notice that we doubled the values of the second equation to keep everything integral.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- matrix(c(1, 1, 1, 6, 4, 1),\n            nrow = 2,\n            ncol = 3,\n            byrow = TRUE)\n\na\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    6    4    1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nb <- as.matrix(c(100, 200))\n\nb\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]  100\n[2,]  200\n```\n\n\n:::\n:::\n\n\n\nThere are at least two main ways to solve this:\n\n  * Brute force. This is kind of the point of computers and programming languages.\n  * Linear algebra, in particular linear algebra over the ring of integers. This approach shows some of the richness of the R package environment curated at [CRAN](https://cran.r-project.org).\n  \nLet's take a quick look at these two solution styles.\n\n## Brute Force Solution\n\nA brute force solution is as follows. First, we get a simple upper bound on each variable. We can do this by checking one row of `a %*% x = b`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nupper_bounds <- floor(b[2] / a[2, ])\nupper_bounds\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  33  50 200\n```\n\n\n:::\n:::\n\n\n\nNow we try all plausible solutions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (x1 in 0:upper_bounds[[1]]) {\n  for (x2 in 0:upper_bounds[[2]]) {\n    # use a row of a to solve for x3\n    x3 <- (b[1] - (a[1, 1] * x1 + a[1, 2] * x2)) / a[1, 3]\n    # check constraints\n    if ((x3 >= 0) && (abs(x3 %% 1) < 1e-8)) {\n      x = as.matrix(c(x1, x2, x3))\n      if (all(a %*% x == b)) {\n        print(c(x1, x2, x3))\n      }\n    }\n  }\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2 30 68\n[1]  5 25 70\n[1]  8 20 72\n[1] 11 15 74\n[1] 14 10 76\n[1] 17  5 78\n[1] 20  0 80\n```\n\n\n:::\n:::\n\n\n\nAnd this gives us exactly the 7 solutions Nina found. This is some of the magic of having a programmable computer: one can cheaply try a lot of potential solutions without needing a lot of theory.\n\n## Ring Theory Solution\n\nIt turns out there is a systematic way to find all of the integral solutions to a linear system quickly, at least for low dimensional solution spaces. To do this we will use a ring theory or linear algebra matrix factorization called the [Hermite normal form](https://en.wikipedia.org/wiki/Hermite_normal_form).  Fortunately, R has a package for this, called  [numbers](https://CRAN.R-project.org/package=numbers). We attach this package as follows.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(numbers)\n```\n:::\n\n\n\nThis package will find for us a lower diagonal integer matrix `h` and a square unimodular matrix `u` such that `h = a %*% u`. Unimodular matrices map the space of integer vectors <code>Z<sup>n</sup></code> to the same space of integer vectors in a 1 to 1, onto, and invertible manner. This means finding integer solution vectors to `a %*% x = b` is equivalent to the problem of finding integer solutions to `h %*% y = b`, where `x = u %*% y`. This second problem is easier, as `h` is lower diagonal- so solving this system is just a matter of \"back filling\".\n\nLet's first find `h, u`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhnf <- hermiteNF(a)\nh <- hnf$H\nu <- hnf$U\nstopifnot(all(h == a %*% u))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# lower triangular transform of a\nh\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    0    0\n[2,]    0    1    0\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# unimodular transform\nu\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    7   -1   -3\n[2,]  -12    2    5\n[3,]    6   -1   -2\n```\n\n\n:::\n:::\n\n\n\nWe now have `a %*% u = h`. `a %*% x = b` implies `h %*% y = b` where `x = u %*% y`. Let's solve for a specific solution `xs` by back substitution.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# back substitute to solve h %*% y = b\n# this uses the fact that h is lower-triangular\nh_rank <- sum(diag(h) != 0)\nstopifnot(h_rank > 1)\ny <- numeric(ncol(a))\ny[1] <- b[1] / h[1, 1]\nfor (i in 2:h_rank) {\n  y[i] <- (b[i] - sum(h[i, 1:(i - 1)] * y[1:(i - 1)])) / h[i, i]\n}\nstopifnot(all(b == h %*% y))\nxs <- u %*% y\nstopifnot(all(a %*% xs == b))\nxs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]  500\n[2,] -800\n[3,]  400\n```\n\n\n:::\n:::\n\n\n\nIt is a standard result of linear algebra that all solutions of `a %*% x = b` are of the form `x = xs + z` where `a %*% z = 0` (that is, `z` is in the null space of `h` and `a`). In our case, the null space is spanned by the last column of `u`.\n\nLet's show this column.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnull_basis <- u[, (h_rank + 1):ncol(u), drop = FALSE]\n\nnull_basis\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1]\n[1,]   -3\n[2,]    5\n[3,]   -2\n```\n\n\n:::\n:::\n\n\n\nSo in our case: all integer solutions of `a %*% x = b` are of the form `[500, -800, 400] + k * [-3, 5, -2]` for integer `k`. \n\nNow we just need to pick `k` to make everything non-negative (an implicit puzzle condition!). The sign changes of entries of `[500, -800, 400] + k * [-3, 5, -2]` happen for `k` where one of the coordinates is equal to zero. These are: \n\n* `500 - 3 * k == 0`\n* `-800 + 5 * k == 0`, and \n* `400 - 2 * k == 0`. \n\nSo the `k` of interest are in the range `ceiling(max(0, 800/5)) <= k <= floor(min(500/3, 400/2))`, or `160 <= k <= 166`. This gives us:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (k in 160:166) {\n  soln <- xs + k * null_basis\n  print(c(soln[1, 1], soln[2, 1], soln[3, 1]))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20  0 80\n[1] 17  5 78\n[1] 14 10 76\n[1] 11 15 74\n[1]  8 20 72\n[1]  5 25 70\n[1]  2 30 68\n```\n\n\n:::\n:::\n\n\n\nAnd these are again exactly the solutions Nina Zumel gave [in the first 100 Bushels post](https://rworks.dev/posts/100bushels/).\n\n## Conclusion\n\nR gives the ability to exploit any combination of innate ability and knowledge, borrowed ability, or brute force in solving problems.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}